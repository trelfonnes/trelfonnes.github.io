<!DOCTYPE HTML>
<!--
	Strongly Typed by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>2D Action RPG - Player Partner</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
	</head>
	<body class="right-sidebar is-preload">
		<div id="page-wrapper">

			<!-- Header -->
				<section id="header">
					<div class="container">

						<!-- Logo -->
							<h1 id="logo"><a href="index.html">Unity: 2D Action RPG</a></h1>
							<p>Inspired by games like Legend of Zelda and Eastward. Scroll to view the unique implementation of various systems.</p>
								<p>(Please Check My <a href="https://github.com/trelfonnes/PlayerPartner"> GitHub Repository</a> for Code Specifics)</p>

						<!-- Nav -->
							<nav id="nav">
								<ul>
									<li><a class="icon solid fa-home" href="index.html"><span>Home</span></a></li>
									
										
									<li><a class="icon solid fa-cog" href="left-sidebar.html"><span>2D Action Platformer</span></a></li>
									<li><a class="icon solid fa-retweet" href="right-sidebar.html"><span>2D Action RPG</span></a></li>
									
								</ul>
							</nav>

					</div>
				</section>

			<!-- Main -->

			<head>
				<style>
					.section {
						display: flex;
						align-items: flex-start;
						border-bottom: 1px solid #ccc;
						padding: 20px 0;
					}
					
					.image {
						flex: 1;
						padding-right: 20px;
					}
					.image img {
            width: 100%;
			padding-bottom: 25px;
            height: auto;
        }
					.bullet {
						flex: 2;
					}
				</style>
			</head>
			<body>
				<div class="section">
					<div class="image">
						<img src="images/CameraSystemPt1.png" alt="Camera System Part 1" width="200" height="150">
						<img src="images/CameraSystemPt2.png" alt="Camera System Part 1">
						<img src="images/CameraSystemPt3.png" alt="Camera System Part 1">
						<img src="images/CameraSystemPt4.png" alt="Camera System Part 1">
					</div>
					
					<div class="bullet">
						<header>
							<h3>CUSTOM CAMERA SYSTEM</h3>
						</header>
						<ul>
							<li>I created a custom cinemachine camera system for dynamically following the human or monster depending on the Player’s current control. </li>
							<li>In these screenshots, notice the Game Objects in the top of the hierarchy. The Room1 and Room2 Game Objects hold the individual cameras. Each room has two cameras, representing the characters they are assigned to. </li>
							<li>The Room Game Object sets the size of the room via a confiner polygon collider.</li>
							<li>As seen in the images, the individual camera’s will be set to active or inactive depending on who the player is controlling and which room the currently active player is in.</li>
							<li>This system utilizes a camera helper class and dynamic reference to the active camera in the Player and Partner scripts for setting the current active camera. </li>
							<li>Previously assigned cameras are set to inactive upon leaving each room, replaced by the correlating camera in the newly entered room.</li>
							<li>The system discriminates when the monster character is being played by receiving information from the Monster’s state classes. I.e. the ‘partner camera’ won’t be active if the game player is not currently controlling them. </li>
							<li>The two playable character have the ability to be in separate rooms and the camera system transitions to and from them seamlessly.</li>
						</ul>
					</div>
				</div>
			
				<div class="section">
					<div class="image">
						<img src="images/DamageInterfaceCombatExample.png" alt="">
						<img src="images/DartThrowExample.png" alt="Camera System Part 1">
						<img src="images/MeleeAttack.png" alt="Camera System Part 1">
						<img src="images/ScytheCutExample.png" alt="Camera System Part 1">
						<img src="images/ACExample.png" alt = "AC Example Image">
						<img src="images/ACExample2.png" alt = "AC Example Image2">
						<img src="images/Weapon ScriptableObject Components.png" alt = "AC Example Image2">
						<img src="images/Weapons and projectiles.png" alt = "AC Example Image2">
						<img src="images/SpreadProjectile.png" alt = "AC Example Image2">


					</div>
					<div class="bullet">
						<header>
							<h3>Limitless Weapon Components! Damage, Knockback, and Poise. </h3>
						</header>
						<ul>
							<li>I created a robust and expansive weapon system, featuring the use of ‘weapon components’ that allow for individual attacks to be customized with varying behaviors.
								Utilize component pattern, MVC pattern, Object pooling, Observer pattern.
								</li>
							<li>For this game, weapons are seperated into two genre’s ‘melee’ and ‘projectiles.’</li>
							<li>The weapon class monobehavior works as a manager for assigning and implementing the weapon features and individual behaviors. It is attached to the primary and secondary weapon game objects to allow for versatile assignment of two different attacks
							</li>
						
							<li>I used scriptable objects to hold weapon specific information for a feature of that weapon.</li>
							<li>Each weapon component needs three types of classes:								:
								<ul>
									<li>Attack data</li>
									<li>'Individual' component</li>
									<li>Weapon data</li>
								</ul>
								<li> Weapons (Scriptable Objects) can hold any number of needed data:
									<ul><li>Animator Controller</li>
										<li>Anything needed by a 'weapon'</li>
										<li>Allows for advanced weapon swapping system by essentially plugging the desired weapon scriptable object into the Weapon Generator class and running a function that sets that new data.
										</li>
										<li>Works in coordination with weapon inventory system (a separate scriptable object) that contains information for the visual representation and description of a weapon but also has the ability to communicate to the Weapon Generator class via a mediator pattern.
										</li>
									</ul>
							</li>
							<li>An Intricate use of Abstraction through interfaces and abstract classes is present in the weapon components. This allows for a similar process of creating a weapon component while allowing for customizable functionality. </li>
							<li>Custom editor scripts are implored for easier accessibility and assignment of weapon components.</li>
							<li>Animation events are used to create precise functionality with what is represented visually to the user</li>
							<li> Works in coordination with the character's state machine:
								<ul><li>Upon player input, character enters 'attack state'
								</li>
									<li>Attack state activities primary or secondary Game Objects</li>
									<li>Allows for advanced weapon swapping system by essentially plugging the desired weapon scriptable object into the Weapon Generator class and running a function that sets that new data.
									</li>
									<li>These objects handle all attack behaviors, including animations, allowing for visually appealing and decoupled animator controllers

									</li>
									<li> Makes for a clean, easy to follow Animator Controller. (See Image)</li>
								</ul>
							</li>
							<header>
								<h3>The Versatility of the system</h3>
							</header>	
							<li>
								Projectiles are a component attached to a weapon scriptable object. 

							</li>
							<li>
								That component holds the ability to assign a projectile type, communicate via observer pattern to the projectile's object pooling class, and pass behavior specific data to that projectile.

							</li>
							<li>
								This is a decoupled, performant, and modular approach to projectiles.

							</li>
							<li>
								Uses Enums as class identifiers and abstraction through the use of classes that define the key value pairing of projectiles and their respective prefab to be pooled.
							</li>
							<Li>
								Projectiles have individual classes that define and implement their behaviors by receiving information from the projectile component.
							</Li>
							<Li>
								Essentially, projectiles are separate from the weapon class and components, but can be ‘called’ and ‘set in place’ by a weapon component as dictated by the user. 
							</Li>
							<li>
								Neither the projectile, nor the weapon component are aware of each other. This allows for an expansive system with straightforward implementation. 
							</li>
							<header>
								<h4>Player Weapons and Tools</h4>
							</header>	
							<li>
								Boomerang:
								<ul>
									<li>
										Thrown in 1 0f 8 directions.
									</li>
									<li>
										Travels a variable distance and returns to point where it was thrown.
									</li>
									<li>
										Capable of interacting with poise interface, applying stun damage to an enemy.
									</li>
									<li> 
										Can return designated items to the player and interact with particular switches.
									</li>
								</ul>
							</li>
							
							<li>
								Scythe:
								<ul>
									<li>
										Tool that cust shrubs blocking access to items and paths.
									</li>
									<li>
										Utilizes ICutable interface upon detection within the Weapon Component 'Action Hit Box'.
									</li>
									<li>CheckHitBox() is called from the animation event within the weapon's Animator Controller.</li>
									
								</ul>
							</li>
							
							<li>
								Whip:
								<ul>
									<li>
										Applies Knockback to enemies.
									</li>
									
								</ul>
							</li>
							
							<li>
								Dart:
								<ul>
									<li>
										Applies ranged stun damage to enemies.
									</li>
									
								</ul>
							</li>
						
							<li>
								Bomb:
								<ul>
									<li>
										Detonates on a timer.
									</li>
									<li>
										Applies Damage to anything within its radius.
									</li>
									<li>Interacts via the IBombable interface.</li>
									
								</ul>
							</li>
					

						<header>
							<h4>Partner Attacks and Projectiles</h4>
						</header>	
						<li>
							Basic Projectile:
							<ul>
								<li>
									Shoot a basic projectile in 1 of 8 directions.
								</li>
							</ul>
						</li>
						
						<li>
							Melee:
							<ul>
								<li>
									A quick, short range attack.
								</li>
							
							</ul>
						</li>
						
						<li>
							Elemental Attack:
							<ul>
								<li>
									A primary attack that can be used in place of the melee.
								</li>
								<li>
									Slow to execute, but deal lots of damage.
								</li>
								
							</ul>
						</li>
						
						<li>
							Charged Projectile:
							<ul>
								<li>
									Hold to charge.
								</li>
								<li>
									Animator signals when charge required has occurred. 
								</li>
								<li>
									Projectile component receives data, and sets the charged projectile to be fired.
								</li>
								<li>Inflicts twice the damage, knockback, and stun of a regular projectile.</li>
								
							</ul>
						</li>
					
						<li>
							Spread Projectile:
							<ul>
								<li>
									Shoots 3 basic projectiles at once.
								</li>
								
							</ul>
						</li>
					</ul>	
				</ul>
					</div>
				
				</div>
				<div class="section">
					<div class="image">
						<img src="images/CoreComponentsDisplay.png" alt="Image 2">
						<img src="images/CoreComponentCollisionSenses.png" alt="Image 2">
						<header>
							<h3>Service Locator Pattern: </h3>
						</header>
						<img src="images/ServiceLocatorPattern.png" alt="Image 2">
						<header>
							<h3>Stat Class Example: </h3>
						</header>
						<img src="images/StatBytesClassExample.png" alt="Image 2">
						<header>
							<h3>Bytes Interface Example: </h3>
						</header>
						<img src="images/InterfaceBytes.png" alt="Image 2">
					</div>
					<div class="bullet">
						<header>
							<h3>CORE COMPONENTS </h3>
						</header>
						<ul>
							<li>Created a straightforward system of classes that hold individual and customizable functions, data, colliders, raycasts, etc. needed by character classes.:
								<ul> <li>e.g. Movement, collisions detection, stats, defeated, particles, etc.</li> 
								</ul>
									<li> This system is able to work with the character's individual state classes via constructor dependency injection at initialization. The reference comes from the 'Player' monobehaviour class that sets reference to the core components through the CoreHandler class.
								</li>
							
							<li>Each component derives from a base class called core components</li>
							<li>The CoreHandler is responsible for retrieving the references and setting them with a Service Locator Pattern (SLP).</li>
							<li>The SLP can be accessed by the different Player states due to the dependency injection from the constructor. </li>
							<li>The SLP utilizes a generic function of type CoreComponent (the deriving class for all components), and allows any component to be retrieved as long as there is access to the CoreHandler class. </li>
							<ul> <li>e.g. The collision class is accessed by the player move state to check information from a raycast to determine if it is in contact with a condition that will change its state. E.g. detecting a carryable object. </li> 
							</ul>
						</ul>
						<header>
							<h3>STAT CORE COMPONENTS </h3>
						</header>
						<ul>
							<li>Created a stat system of core components that account for all types of stats i.e. Health, Stamina, MP, Evolution Points, Keys, sick, injured, Bytes
								:
								<ul> <li>Each stat component derives from the Base 'stat' class.</li> 
								</ul>
									<li> A character does NOT have to implement all stat components. It can only have the ones it needs and because they derive from the base stat class, the service locator pattern can still access them for use by the player’s state machine.

								</li>
							
							<li>This gives them access to common functionalities as defined by the stat base class.
							</li>
							<li>The purpose of the individual stat classes is to function as a HUB for game objects to facilitate interact with player data. If Player data is to be changed, it must be done through the respective stat class.
							</li>
							<li>Stat classes also account for congruency in player data. 
							</li>
							<li>They are responsible for triggering ‘stat events’ events found in scriptable objects that can be subscribed to to let systems know health is at zero, or stamina meter is empty. 
							</li>
							<ul> <li>Each stat class has its own interface implementation, and holds the required functions to make that stat accessible by other game objects. I.e. hearts, meats, ammo, detrimental items. 
							</li> 
							</ul>
						</ul>
					</div>

				</div>

				<div class="section">
					<div class="image">
						<header>
							<h3>State References </h3>
						</header>
						<img src="images/StateReferencesinPartnerClass.png" alt="Image 2">
						<header>
							<h3>State Machine </h3>
						</header>
						<img src="images/StateMachine.png" alt="Image 2">
						<header>
							<h3>Individual State Example (super state) </h3>
						</header>
						<img src="images/StateBasicExample.png" alt="Image 2">
					</div>
					<div class="bullet">
						<header>
							<h3>Player State Machine </h3>
						</header>
						<ul>
							
							<li>Developed a state machine pattern with the ability to maintain player behaviors, data, and interactions.
							</li>
							<li>Utilize: Constructor, dependency injection, State Pattern, Observer Patterns, abstraction.</li>
							<li>
								Three main classes involved:
								<ul> <li> PlayerState, StateMachine, Player.
								</li></ul> 

							</li>
							<li>
								Classes that derive from PlayerState can change to and from each other based on conditions by sending desired state’s reference. Deriving states have access to this process from initialization in the Player State class. Generating the constructor and overrides allow them to connect efficiently. 
 
							</li>
							
						
						</ul>
					</div>


				



				</div>
				<div class="section">
					<div class="image">
						<img src="images/KeyDoorClosed.png" alt="Image 2">
						<img src="images/WrongKeyExample.png" alt="Image 2">
						<img src="images/OpenKeyDoor.png" alt="Image 2">
					</div>
					<div class="bullet">
						<header>
							<h3>Dynamic Key System </h3>
						</header>
						<ul>
							<li>There are two types of keys:
								<ul> <li>1. Regular Keys</li> <li> 2. Boss keys</li>
							</ul>
							<li>Keys are part of the STAT CORE COMPONENT ***(see Above)
							</li>
							<li>The individual data is stored in a scriptable object referenced through that component's instance.</li>
							<li>
								The only way to change the data is by going through the IKeys interface.

							</li>
							<li>
								The interface is called by the Key Door class and checks to see how many keys the player is holding of the required key type. 
							</li>
							<li>
								The Key Door is responsible for defining the amount and type of key(s) to open and executing desired behavior if conditions are met. 
							</li>
						<li>If the KeyDoor class finds the player meets the requirements, it subtracts the defined amount of keys from the Player’s data. I.e. The Key class receives this information and applies it to the UI and scriptable object (Player Data) as seen in the images. </li>
						
						
						</ul>
					</div>
				
				</div>
				<div class="section">
					<div class="image">
						<img src="images/ShopInventory.png" alt="Camera System Part 1" width="200" height="150">
						<img src="images/ShopPurchaseExample.png" alt="Camera System Part 1">
						<img src="images/ShopNotEnoughBytes.png" alt="Camera System Part 1">
						<img src="images/ShopPurchaseSpawnPoint.png" alt="Camera System Part 1">
					</div>
					
					<div class="bullet">
						<header>
							<h3>SHOP SYSTEM</h3>
						</header>
						<ul>
							<li>Created a shop system with merchant who sells a regular stock of items i.e.(potions, hearts, meat etc.) but also has the capability to sell a special, single-purchase item i.e.(a key item or weapon)
							</li>
							<li>Use scriptable objects to define item-specific details. I.e. how many in stock, description, name, prefab to instantiate. </li>
							<li>MVC pattern similar to Weapon and Inventory systems listed above.</li>
							<li>Controller (ShopManager) class handles logic by receiving information from the model and View, then executes desired functionality. </li>
							<li>Bytes(in-game currency) are checked by the shop manager, via interface, then subtracted from player’s inventory if the minimum cost requirement is met.  </li>
							<li>ShopManager also takes care of signaling to the View that the player does not have enough currency, and Bytes are not subtracted.
							</li>
							<li>If currency is greater than or equal to the item, the purchase will be made and the item will spawn next to the shop keeper for the player to pick up. This makes use of the system already in place for picking up items, and allows for the shop to have a greater variety of items like hearts and meat, which are overworld exclusive items and not inventory items.
							</li>
							
						</ul>
					</div>
				</div>
			</div>
			<div class="section">
				<div class="image">
					<img src="images/ConditionSickHurt.png" alt="Camera System Part 1" width="200" height="150">
					<img src="images/MedicineBandaidInInventory.png" alt="Camera System Part 1">
					<img src="images/MedicineBandaidUsedConditionCHanged.png" alt="Camera System Part 1">
					
				</div>
				
				<div class="bullet">
					<header>
						<h3>Status Conditions: Sick and Injured</h3>
					</header>
					<ul>
						<li>Created a gameplay mechanic that simulates ‘caring for’ you partner creature.

						</li>
						<li>'Hunger' or stamina meter decreases as in-game hours pass.
						</li>
						<li>Player must find food for partner to eat or purchase a stamina potion to refill meter.</li>
						<li>Partner can become sick or injured when coming into contact with gameplay elements. </li>
						<li>When status condition occurs, UI elements update and stats (health and Stamina) are affected. 
						</li>
						<li>To cure sick or injured status, player must purchase or find a medicine bottle or bandaid and use it on their partner creature. 
						</li>
						<li>Once cured, the stats will stop being affected.
						</li>
						<li>Makes use of interfaces, event subscription, scriptable objects, UI elements.
						</li>
					</ul>
				</div>
			</div>

		</div>
		<div class="section">
			<div class="image">
				<img src="images/CollectEvolutionDevice.png" alt="Camera System Part 1" width="200" height="150">
				<img src="images/Stage2Evolution.png" alt="Camera System Part 1">
				<img src="images/Stage2Evolved.png" alt="Camera System Part 1">
				<img src="images/ReturnToTrainerDevolve.png" alt="Camera System Part 1">
			</div>
			
			<div class="bullet">
				<header>
					<h3>Custom Evolution System</h3>
				</header>
				<ul>
					<li>Built a custom evolution system that functions in coordination with numerous in game systems. Creates strategic gameplay functions for the user. 

					</li>
					<li>Evolution is reliant upon collecting the evolution necklace and having enough Evolution Points: a type of currency gathered by the player. This data is shared and accessed by all evolutionary stages to allow for consistent implementation.
					</li>
					<li>Evolution consists of 3 stages: all are their own separate game objects, but utilize various mediator patterns, Animation events, observer patterns, scriptable objects, and levels of abstraction to allow for individualized behavior and stats while maintaining symmetrical aspects of control. </li>
					<li>A player Mover class manages which stage is active and inactive, it rotates the objects in and out of the scene, upon receiving information from the animator’s state enter and exit functions when the evolution state is entered.  </li>
					<li>System works in coordination with the Evolution Points (EP). 
						<ul> <li>Think super sonic in sonic the hedgehog.</li> <li> Once evolved, the EP counts down in one point increments per second. When the timer reaches zero, an event is triggered to cause the monster to ‘devolve’ returning to its initial stage and losing the gameplay buffs from evolution. </li>
							<li>Objects can be collected to restore EP or extend ‘evolution time’ by accessing the Evolution Points Core Component.</li>
							
						</ul> 
					</li>
					
				</ul>
			</div>
		</div>
	</div>
	<div class="section">
		<div class="image">
			<img src="images/CampFireLit.png" alt="Camera System Part 1" width="200" height="150">
			<img src="images/NightCycleExample.png" alt="Camera System Part 1">
			<img src="images/TorchEveningLight.png" alt="Camera System Part 1">
			<header>
				<h3>Save Data serialization example:</h3>
			</header>
			<img src="images/SaveManager.png" alt="Camera System Part 1" height="500">
		</div>
		
		<div class="bullet">
			<header>
				<h3>2D Lighting with Unieversal Render Pipeline</h3>
			</header>
			<ul>
				<li>Created a 2D lighting system by utilizing the universal render pipeline.
				</li>
				<li>Implemented global light system that subscribes to a clock ticking class. It tracks the hours passed and sets lighting appropriate for the time of day. It also fires individual events to signal what time of day it is. This allows for in-game specific conditions to be triggered based on what time of day it is. 
				</li>
				<li>The campfire mechanic is an example of that. The campfire is initially inactive, but upon brining an active fire to the campfire, it will be ignited.
				</li>
				<li>This works through an interface ILightable.  </li>
				<li>The campfire also subscribes to the Time of Day Manager. It listens to the time of day events and changes its lighting intensity. E.g. light will decrease during ‘daylight’ hours.  
					
				</li>
				<li>Campfire also utilizes the IInteractable interface to save the game data locally via binary serialization to a JSON file.</li>
				<li>Campfire also carries a collider that repels enemies or causes enemies to meet a condition to change their ‘chase’ state to’ retreat’ state upon interaction with the collider.</li>
			</ul>
		</div>
	</div>

</div>
<div class="section">
	<div class="image">
		<img src="images/WeaponInventoryCollection.png" alt="Camera System Part 1" width="200" height="150">
		<img src="images/InventoryPanelsExample.png" alt="Camera System Part 1">
		<img src="images/PlayerInvenotryItems.png" alt="Camera System Part 1">
		
	
	</div>
	
	<div class="bullet">
		<header>
			<h3>Weapon and Basic Inventory System</h3>
		</header>
		<ul>
			<li>Inventory follows an MVC pattern.

			</li>
			<li>Weapon Inventory Manager class (controller)
 
			</li>
			<li>Weapon Panel Game Objects (Model)
			</li>
			<li>Interactive UI elements (View)
			</li>
			<li>Player collects a new weapon item and it is added to the weapon inventory.
				
			</li>
			<li>The weapon inventory itself is a scriptable object</li>
			<li>The inventory items are also scriptable objects, they are added to the inventory SO upon collection.
			</li>
			<li>The weapon inventory is read by the weapon inventory manager.
			</li>
			<li>It iterates over the contents and assigns the details to an inventory panel and the panel is displayed as a UI element, accessible through the Menu screen.
			</li>
			<li>The player has the ability to select the weapon panel, signaling to the manager to display the description text of the weapon and make the ‘equip’ button available. </li>
			<li>Upon pressing ‘equip’ a few things happen. </li>
			<li>
				The manager sends information to a mediator class with an enum that identifies the weapon that was currently equipped.
			</li>
			<li>
				This information is saved and stored for access by the weapon generator class, and the weapon generator class accesses this mediator class and uses it to set its key value pairing for the appropriate weapon scriptable object data. It takes the correlating data and plugs it into its system, effectively swapping the weapon.

			</li>
			<li>
				What’s more, this allows for congruence of weapons equipped between all stages of evolution. After evolving, or being set to active, the weapon generator class knows to check the mediator class for weapon assignment, effectively allowing the monster’s evolution stages to persist the assigned weapon (attack). 
			</li>
		</ul>
	</div>
</div>

</div>
<div class="section">
	<div class="image">
		<img src="images/MechanicsPitfallJump.png" alt="Camera System Part 1" width="200" height="150">
		<img src="images/PitfallTransformPlacement.png" alt="Camera System Part 1">
		<img src="images/OpenChestExample.png" alt="Camera System Part 1">
		<img src="images/Stage3Attacking.png" alt="Camera System Part 1">
		<img src="images/EvolvedPushBoulder.png" alt="Camera System Part 1">
	
	</div>
	
	<div class="bullet">
		<header>
			<h3>Misc. Game Mechanics</h3>
		</header>
		<ul>
			<li>Created a number of gameplay mechanics adding depth, strategy, and variety to player experience.
			</li>
			<li>Top down 2D jump ability similar to titles like LOZ: link’s Awakening.
 
			</li>
			<li>Dash ability with varying cooldown.
			</li>
			<li>Evolution specific abilities like pushing objects.
			</li>
			<li>Bombable walls to reveal hidden items or paths.

			</li>
			<li>Game objects interactable with specific tool or weapon component (interface) e.g. cut shrubs.</li>
			<li>Carryable and throwable objects</li>
			<li>Hitting Switches.</li>
			<li>Opening chests</li>
			<li>Item Spawn System **(Description coming)</li>
		</ul>
	</div>
</div>
				<!-- Add more sections as needed -->
			
			</body>
			</html>